- [Compliance](#compliance)
  - [11.1 How to ensure traceability of work](#111-how-to-ensure-traceability-of-work)
    - [11.1.1 How to ensure commits are traceable](#1111-how-to-ensure-commits-are-traceable)
  - [11.2 How to enforce the four-eyes principle](#112-how-to-enforce-the-four-eyes-principle)
    - [11.2.1 Enforcing segregation of duties with CODEOWNERS file](#1121-enforcing-segregation-of-duties-with-codeowners-file)
    - [11.2.2 Showing end-to-end traceability](#1122-showing-end-to-end-traceability)
  - [11.3 Mandatory workflows](#113-mandatory-workflows)
  - [Summary](#summary)

# Compliance

This chapter covers

* Ensuring your work and commits are traceable
* Enforcing the four-eyes principle in pull requests
* Setting up the CODEOWNERS file to enforce reviewers
* Enabling mandatory workflows

This chapter helps you set up your GitHub workflows so that you can comply with almost any compliance framework in use in the industry. Regarding compliance, most compliance frameworks have two primary risk mitigations you need to implement to be compliant. First, you need to have the ability to prove who has made a change and show what changed and at which point in time. This is often referred to as traceability. Second, you need to be able to enforce this change being reviewed by someone else—preferably, someone with a different role in the change process. This process is referred to as the four-eyes principle. In this chapter, we describe how to enable these controls so that you can comply with most industry frameworks.

## 11.1 How to ensure traceability of work

One of the greatest benefits of using a version control system like Git is that it has all the basic requirements in place to support the traceability of work. When we use standard Git, we already have traceability regarding what was changed, by whom it was changed, and at what moment in time it was changed. The last step before we achieve full traceability is being able to tie this to a person in the organization. GitHub has multiple ways of dealing with users. The most commonly used way is to log into Git using a GitHub handle and providing your password to identify that you are who you claim to be. To enforce stronger authentication, two-factor authentication is also enforced with either the GitHub companion app on your phone or by providing a one-time code generated by an OTP generator, like the Google or Microsoft Authenticator apps.

For enterprises, this is often not enough because they need to be able to tie a GitHub handle to a real employee in their organization. Enterprises prefer to enable authentication against their identity provider of choice. This can be, for example, Okta or Microsoft Entra ID. This is referred to as single sign-on (SSO), since the user is only asked to log in to their workspace once and is granted access to GitHub using the configured identity provider.

GitHub supports two ways of enabling SSO: using Security Assertion Markup Language (SAML) and enabling so-called enterprise-managed users (EMU). SAML SSO gives organization owners and enterprise owners using GitHub Enterprise Cloud a way to control and secure access to organization resources like repositories, issues, and pull requests (PRs). Organization owners can invite your personal account on GitHub to join their organization that uses SAML SSO, which allows you to contribute to the organization and retain your existing identity and contributions on GitHub.

When GitHub is configured to use EMU, a user will get an account from their organization. This account is restricted to only being used in the enterprise, and you cannot publish public repositories using these accounts. Enterprises often prefer EMU accounts, since this provides a single point of administration in the organization and better protection against exposing IPs to the outside world. This improves compliancy by making it possible to trace a change back to an identity. This identity is either a GitHub handle, a GitHub handle tied to an identity provider using SAML, or an EMU.

### 11.1.1 How to ensure commits are traceable

When you use the GitHub website and make a change to a file, the traceability is rather simply enforced. You are logged in as a user, and that identity is tied to your commit.

Git is a distributed version control system that allows you to work disconnected on a local machine and make changes locally. This means anyone who has access to the cloned repository can make changes and commit them to the history. In your Git history, you can see who committed this code, but that is something anyone can set to any name and email address they like. There is no authentication or validation of the name and email address of the committer. This may pose a threat in the form of someone making changes in the history that look like they were made by a legitimate user and email address but are actually from a thread actor. For this, we can enable branch protection and demand that all commits are signed. You can set this up in the branch protection rules for your branches. Figure 11.1 shows the item to check.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH11_F01_Kaufmann.png)<br>
**Figure 11.1 Enforcing signed commits**

To set up signed commits on GitHub, you can follow these steps:

1. First, you need to generate a GPG key pair. You can use various tools to generate this key. For Mac users, the GPG Suite allows you to store your GPG key passphrase in the macOS keychain. For Windows users, Gpg4win integrates with other Windows tools.

2. Once you have generated your GPG key pair, you must tell Git about your signing key. You can do this by running the following command in your terminal: `git config --global user.signingkey YOUR_GPG_KEY_ID`. Replace `YOUR_GPG_KEY_ID` with the ID of your GPG key.

3. Next, you must configure Git to sign all commits by default. You can do this by running the following command in your terminal: `git config --global commit.gpgsign true`

4. Finally, you can sign your commits by adding the `-S` flag to your `git commit` command, as in the following example: `git commit -S -m "Your commit message"`.

Now, all of your commits, regardless of the Git UI tool you are using, will be signed with your GPG key. It is also possible to sign using S/MIME configuration or even with an SSH key that works better in your day-to-day workflow.

The moment you push your changes to GitHub and have unverified commits in your history, it will block the push with an error message. This is shown in figure 11.2.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH11_F02_Kaufmann.png)<br>
**Figure 11.2 Signed commit enforced**

In the commit history of your repo, you can also see if verified users have made commits. This is shown in figure 11.3.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH11_F03_Kaufmann.png)<br>
**Figure 11.3 Verified commits in history**

Using the signed commits on your branch protection, you should be able to satisfy any compliance requirements. Enabling and disabling the branch protection rules is an audited event, so there is also traceability of these rules being changed. Changing these settings is a privileged operation and cannot be done by a standard GitHub user; you need to be an administrator (repo) for this.

## 11.2 How to enforce the four-eyes principle

The four-eyes principle is there to ensure any given developer cannot make a change without any other person being involved. This is a very common risk mitigation control used by many compliance frameworks. You can enforce this principle at two primary locations in GitHub. The first location is at the source control level, and enforcing each change to the sources must be reviewed by someone else. The second place is at the continuous deployment stage of GitHub Actions workflows. This was discussed in chapter 8 and relates to the use of environments. To enforce code reviews on your main branch, enable branch protection rules. Select Require Pull Requests Before Merging, and select Require Approvals. This will block anything from being merged to main without a PR. On top of this, don’t forget to block bypassing this rule by administrators—that way, the rules apply to everyone. You can see the selected options in figure 11.4.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH11_F04_Kaufmann.png)<br>
**Figure 11.4 Branch protection rules**

> [!NOTE]
> 
> Administrators could bypass the rule by first disabling the branch protection rule, then committing a change directly to the main, and then re-enabling the branch protection rule. Changing anything in branch protection rules is audited and will show up in any audit logs you can download in your enterprise administrator dashboard. So while it seems you can bypass this, it will not go unnoticed.

We can even improve this experience if you need to enforce segregation of duties. For this, we can use the CODEOWNERS file.

### 11.2.1 Enforcing segregation of duties with CODEOWNERS file

The CODEOWNERS file is a special file that defines who is responsible for specific parts of the repository. To use a CODEOWNERS file, create a new file called CODEOWNERS in the .github/, the root, or docs/ directory of the repository in the branch where you’d like to add the code owners. If the CODEOWNERS files exist in more than one of those locations, GitHub will search for them in that order and use the first one it finds. In the CODEOWNERS file, you can specify, for example, that a team with the name lead-developers is the owner of our catalog, frontend, and ordering sources and that a team DevOps-engineers is responsible for the workflow files in the .github/workflows folder.

The CODEOWNERS file uses a pattern that follows most of the same rules used in gitignore files. The pattern is followed by one or more GitHub usernames or team names using the standard @username or @org/team-name format. Users and teams must have explicit write access to the repository, even if the team’s members already have access.

You can enforce that these CODEOWNERS are required to do the reviews by adding the option Require Review from Code Owners to the branch protection rule. If you don’t enforce this, the owner will be notified someone is working on the files, but merging is not blocked. The CODEOWNERS file is shown in the following listing, which shows how to configure the file based on these review enforcements.

**Listing 11.1 CODEOWNERS File**

```CODEOWNERS
# The catalog, ordering, and frontend folders are reviewed by the lead developers team.
catalog/ ordering/ frontend/ @lead-developers
  
# Action workflows are reviewed by the devops engineers team.
.github/workflows/ @devops-engineers
```

The CODEOWNERS file itself can also be part of the definition. So you can assign a special team that requires any changes to this file to add even more layers of review. Note, only one code owner needs to approve, even if you configure a team.

### 11.2.2 Showing end-to-end traceability

You can track the full traceability of a change when you adhere to all the previously mentioned steps. This way, you can provide continuous compliance. The way to track a change to production is discussed in this section.

The environment will show the currently deployed version of the software. You can click this because the release creation also created a tag on the Git repository. This is shown in figure 11.5.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH11_F05_Kaufmann.png)<br>
**Figure 11.5 Deployments view**

Based on this change, you can track the history in version control. As you can see, the deployment shows the reference to the PR that defined the change. This PR refers to the requirement defined in an issue. You can see this provides full traceability from a deployment to a requirement and all the changes made in the source code.

You can also validate whether a four-eyes principle was applied, since you can trace back the PR that was responsible for the merge to the main branch. That PR contains the approval as part of the required review, enforced by the branch policy. So by setting up a branch policy and by using PRs, environments, and approvals, you can enforce full end-to-end traceability from requirement to deployment, satisfying most compliance frameworks used in various industries.

## 11.3 Mandatory workflows

You can standardize and enforce CI/CD best practices across all repositories in your organization to reduce duplication and secure your DevOps processes. Mandatory workflows empower DevOps teams to establish and enforce uniform CI/CD procedures across numerous source code repositories within an organization, without requiring each team to go through the process of configuring each repository individually, something that is more or less undoable in large-scale organizations. Beyond the reduction of redundant CI/CD configuration code, mandatory workflows provide valuable support in the following scenarios:

* *Compliance*—Guaranteeing that all code adheres to an enterprise’s quality standards, thereby ensuring regulatory compliance
* *Security*—Facilitating the integration of external vulnerability scoring and dynamic analysis tools to fortify code security
* *Deployment*—Ensuring code is consistently and systematically deployed in accordance with established standards

Organization admins can configure required workflows to run on all or selected repositories. The configuration for this is shown in figure 11.6.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH11_F06_Kaufmann.png)<br>
**Figure 11.6 Configuring required workflows**

Mandatory workflows will activate as necessary status checks for all PRs initiated on the default branch. These status checks serve as prerequisites for merging the PR, ensuring the required workflow successfully completed before proceeding. You can see this required status check in the PR validation in figure 11.7. At the repository level, individual development teams will have visibility into the specific mandatory workflows applied to their repository.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH11_F07_Kaufmann.png)<br>
**Figure 11.7 Required status check**

## Summary

* The key aspects of making sure your organization complies with regulatory bodies are ensuring the traceability of changes and enforcing the four-eyes principle for code review.

* Linking changes to user identities is best configured by using single sign-on and implementing signed commits.

* You can use branch protection rules and the CODEOWNERS files to enforce code reviews and segregation of duties.

* By creating mandatory workflows, you can empower your organization to standardize and enforce CI/CD practices, ensure code quality, enhance security, and streamline deployment.