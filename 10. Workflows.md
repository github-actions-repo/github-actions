- [Workflows](#workflows)
  - [3.1 YAML](#31-yaml)
    - [3.1.1 YAML basics](#311-yaml-basics)
    - [3.1.2 Data types](#312-data-types)
      - [Scalar types](#scalar-types)
      - [Collection types](#collection-types)
  - [3.2 The workflow syntax](#32-the-workflow-syntax)
  - [3.3 Events and triggers](#33-events-and-triggers)
    - [3.3.1 Webhook triggers](#331-webhook-triggers)
    - [3.3.2 Scheduled triggers](#332-scheduled-triggers)
  - [3.3.3 Manual triggers](#333-manual-triggers)
  - [3.4 Workflow jobs and steps](#34-workflow-jobs-and-steps)
    - [3.4.1 Workflow jobs](#341-workflow-jobs)
    - [3.4.2 Workflow steps](#342-workflow-steps)
    - [3.4.3 Using GitHub actions](#343-using-github-actions)
    - [3.4.4 The matrix strategy](#344-the-matrix-strategy)
  - [3.5 Expressions and contexts](#35-expressions-and-contexts)
  - [3.6 Workflow commands](#36-workflow-commands)
    - [3.6.1 Writing a debug message](#361-writing-a-debug-message)
    - [3.6.2 Creating error or warning messages](#362-creating-error-or-warning-messages)
    - [3.6.3 Passing an output to subsequent steps and jobs](#363-passing-an-output-to-subsequent-steps-and-jobs)
    - [3.6.4 Environment files](#364-environment-files)
  - [3.6.5 Job summaries](#365-job-summaries)
  - [3.7 Secrets and variables](#37-secrets-and-variables)
  - [3.8 Workflow permissions](#38-workflow-permissions)
  - [3.9 Authoring and debugging workflows](#39-authoring-and-debugging-workflows)
  - [3.10 Conclusion](#310-conclusion)
  - [Summary](#summary)

# Workflows

This chapter covers

* Understanding YAML and the YAML syntax
* Learning the basics of the workflow syntax
* Understanding workflow triggers, expressions, and contexts
* Introducing advanced workflow concepts, like workflow commands
* Learning best practices for authoring and debugging workflows

Now that you have gained a bit of practical experience, it is time to fully understand the syntax for workflows. Since workflows are written in YAML, it is important to fully understand YAML before writing workflows.

## 3.1 YAML

*YAML*, which stands for *YAML Ain’t Markup Language*, is a data-serialization language optimized to be directly writable and readable by humans. It is a strict superset of JSON but with syntactically relevant newlines and indentation instead of braces. In the next sections, we go through all the YAML elements that are important for writing workflows.

### 3.1.1 YAML basics

YAML files are text files with a .yml or .yaml extension. Because YAML uses indentation instead of braces, these text files can be versioned very well with Git, as changes are always made per line.

YAML files can have different encodings, but GitHub uses UTF-8 for the workflows. You can write comments in YAML by prefixing text with a hash (#):

```yml
# A full-line comment in YAML
key:value # An in-line comment
```

Comments can occur anywhere in a line.

### 3.1.2 Data types

In YAML, you have various data types available. There are simple (scalar) data types as well as more complex collection types.

#### Scalar types

In YAML, you can assign a value to a variable with the following syntax:

```yml
key: value
```

The key is the name of the variable. The type of the variable will be different, depending on the data type of value. In listing 3.1, you can see the syntax for all basic data types: integer, float, string, Boolean, and datetime. Please note that in the listing, the key is just the name of the variable, so `age: 42` will assign the value `42` to an integer variable called `age`.

**Listing 3.1 Assigning basic scalar types to variables in YAML**

```yml
integer: 42
float: 42.0
string: a text value
boolean: true
null value: null
datetime: 1999-12-31T23:59:43.1Z
```

> [!NOTE] Types in YAML
>
> Types in YAML are more complex. For example, the datetime format—called timestamp format in YAML—can be written in multiple forms, but I see this as barely relevant for authoring workflows. If you want to learn more about types in YAML, please see the documentation at: https://yaml.org/type.

Note that keys and values can contain spaces and do not need quotation! You can quote keys and values with single or double quotes, but you only have to do so if they contain special characters or if the characters would indicate an incorrect data type to YAML. Double quotes use the backslash as the escape pattern; single quotes use an additional single quote for this:

```yml
'single quotes': 'have ''one quote'' as the escape pattern'
"double quotes": "have the \"backslash \" escape pattern"
```

This is especially important to understand for writing scripts in YAML workflows.

String variables can also span multiple lines using the pipe operator and a four spaces indentation. The multiline text block can also contain line breaks and empty lines and continues until the next element:

```yml
literal_block: |
    Text blocks use four spaces as indentation. The entire
    block is assigned to the key 'literal_block' and keeps
    line breaks and empty lines.
  
    The block continuous until the next YAML element with the same
    indentation as the literal block.
```

This makes writing complex scripts in YAML workflows much easier than in other formats where you must quote variables.

#### Collection types

In YAML, there are two different collection types: nested types called maps and lists, which are also called sequences.

Maps use two spaces of indentation and the same syntax as assigning variables:

```yml
parent:
  key1: value1
  key2: value2
  child:
    key1: value1
```

Since YAML is a superset of JSON, you can also use the JSON syntax to put maps in one line:

```yml
parent: {key1: value1, key2: value2, child: {key1: value1}}
```

A sequence is an ordered list of items and has a dash before each line:

```yml
sequence:
  - item1
  - item2
  - item3
```

You can also write this in one line, using the JSON syntax:

```yml
sequence: [item1, item2, item3]
```

> [!NOTE] Learn more about YAML
>
> This is just the tip of the iceberg, and there is so much more you can learn about YAML. For working with GitHub Action workflows, many topics are not relevant. Topics like file directives (`---`); tags; and the different syntax variations for scalar types, such as datetime or decimal and folded literal block (with `>` instead of `|`) are unnecessary for writing workflows effectively. If you want to dive deeper in the YAML syntax you can visit YAML’s website at: https://yaml.org/spec/1.2.2/#13-terminology.

This is enough YAML knowledge to understand the workflow syntax.

## 3.2 The workflow syntax

The first element in a workflow file is typically the name of the workflow. The workflow can have a different name than the workflow file itself. In the example in chapter 2, the workflow file is named MyFirstWorkflow.yml, but the workflow itself is named `My First Workflow`. The name is set using the name property:

```yml
name:
  My First Workflow
```

This is just a convention. You could also start the workflow file with one of the other valid root elements. The name property is typically followed by the triggers that start the workflow. You also might want to add a comment on top of the workflow to document what the workflow does.

## 3.3 Events and triggers

There are three categories of triggers:

* Webhook triggers
* Scheduled triggers
* Manual triggers

All triggers follow the key `on:` in the workflow file.

### 3.3.1 Webhook triggers

Webhook triggers start the workflow based on an event in GitHub. This can be a `git push` to the repository:

```yml
on: push
```

It can also be a pull request in the repo:

```yml
on: [push, pull_request]
```

Most webhook triggers can be configured to only start the workflow on certain conditions. You can, for example, start a workflow only when pushing to certain `branches` or pushing when certain files in a path (`paths`) have been updated. The following example will only trigger the workflow when files in the doc folder have changed, and the changes are pushed to the main branch or a branch starting with release/:

```yml
on:
  push:
    branches:
      - 'main'
      - 'release/**'
    paths:
      - 'doc/**'
```

> [!NOTE]
> 
> The `*` character is a special character in YAML, so you have to quote all strings that contain values with wildcards.

There are many webhook triggers available—for example, you could run a workflow on an `issues` event. Supported activity type filters are `opened`, `edited`, `deleted`, `transferred`, `pinned`, `unpinned`, `closed`, `reopened`, `assigned`, `unassigned`, `labeled`, `unlabeled`, `locked`, `unlocked`, `milestoned`, and `demilestoned`. Any of these events occurring in an issue will trigger the workflow to run.

You can also run a workflow when your repository is starred (`watch`); a `branch_protection_rule` is created, edited, or deleted; or when your repository visibility is changed from `private` to `public`. For a complete list of the events that can trigger workflows, please refer to the [documentation][1].

### 3.3.2 Scheduled triggers

Schedule triggers allow you to start a workflow at a scheduled time—they use the same syntax as cron jobs. The syntax consists of five fields that represent the minute (`0–59`), hour (`0–23`), day of month (`1–31`), month (`1–12` or `JAN–DEC`) and day of week (`0–6` or `SUN–SAT`). You can use the operators shown in table 3.1.

**Table 3.1 Operators for scheduled events**

| **Operator** | **Description**                                      |
|--------------|------------------------------------------------------|
| `*`          | Any value                                            |
| `,`          | Value list separator if you specify multiple values  |
| `-`          | Range of values (from–to)                            |
| `/`          | Step values                                          |

The following listing shows some examples of scheduled triggers and when and how often they would be triggered.

Listing 3.2 Examples of scheduled workflows

```yml
on:
  schedule:
    # Runs at every 15th minute
    - cron:  '*/15 * * * *'
    # Runs every hour from 9am to 5pm
    - cron:  '0 9-17 * * *'
    # Runs every Friday at midnight
    - cron:  '0 0 * * FRI'
    # Runs every quarter (00:00 on day 1 every 3rd month)
    - cron:  '0 0 1 */3 *'
```

As you can see in the examples, you can combine multiple schedule triggers in the same workflow, which can be helpful if you have a combination of multiple timings. The workflow designer is a great help when writing scheduled triggers, as it will translate the cron job syntax into a human-readable string (see figure 3.1).

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F01_Kaufmann.png)<br>
**Figure 3.1 The workflow editor translates the cron job syntax into a human-readable string.**

## 3.3.3 Manual triggers

Manual triggers allow you to start a workflow manually. To do this using the GitHub UI or CLI, you can use the `workflow_dispatch` trigger:

```yml
on: workflow_dispatch
```

The trigger always accepts one input: the branch the workflow runs on. The value defaults to the default branch of the repository, normally `main`. In the GitHub UI, you can trigger the workflow with the dialog displayed in figure 3.2.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F02_Kaufmann.png)<br>
**Figure 3.2 Triggering a workflow manually**

You can also trigger the workflow using the GitHub CLI, either by name, ID, or filename relative to .github/workflow:

```sh
gh workflow run WORKFLOW_FILENAME
```

The name of the workflow might contain blanks, which means you must quote it on the command line. The workflow ID can be obtained by running `gh workflow list`, but the most practical approach is normally the name of the workflow file.

You can configure custom input arguments for a manual workflow start. The inputs can be required, they can be optional, or you can provide default values. They can have the type `string`, `boolean`, or `choice`. For `choice`, you provide a list of values that do not change. There is also the special type called `environment` that will give you a choice field over all environments found in the repository. (Environments have to be created manually in the repository. You will learn more about secrets and environments later in this chapter). The following listing provides an example that provides different custom inputs for a manual trigger.

**Listing 3.3 Custom inputs for the workflow_dispatch trigger**

```yml
workflow_dispatch:
  inputs:
    homedrive:
      description: 'The home drive on the machine'
      required: true
    logLevel:
      description: 'Log level'
      default: 'warning' 
      type: choice
      options:
      - info
      - warning
      - debug 
    tag:
      description: 'Apply tag after successfull test run'
      required: true 
      type: boolean 
    environment:
      description: 'Environment to run tests against'
      type: environment
      required: true
```

If the workflow is triggered through the user interface, the inputs are entered in a generated form, like in figure 3.3.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F03_Kaufmann.png)<br>
**Figure 3.3 Providing a custom-defined input when starting a workflow in the UI**

If you trigger the workflow using the CLI, it will prompt you for the inputs. Alternatively, you can pass the inputs to the command using the `-f (--field)` argument:

```sh
gh workflow run MyFirstWorkflow.yml -f homedrive=/home -f logLevel=warning -f tag=true -f environment=Staging
```

If you already have the input in JSON format, you can pipe it into the command using the standard input together with the `--json` switch:

```sh
echo '{"homedrive":"/home", "environment":"Staging", "tag":"true"}' | gh workflow run MyFirstWorkflow.yml --json
```

In the workflow, the values of the inputs can be accessed using the `inputs` context:

```yml
steps:
  - run: |
      echo "Homedrive: ${{ inputs.homedrive }}"
      echo "Log level: ${{ inputs.logLevel }}"
      echo "Tag source: ${{ inputs.tag }}"
      echo "Environment ${{ inputs.environment }}"
    name: Workflow Inputs
    if: ${{ github.event_name == 'workflow_dispatch' }}
```

You will learn more about context and expression syntax in the next section of this chapter.

Another manual trigger is the `repository_dispatch` trigger, which can be used to start all workflows in the repository that listen to that trigger using the GitHub API. This trigger can be used for integration scenarios with other systems.

If added to a workflow, the trigger can have one or more event types that can then be specified when calling the API if you only want to trigger certain workflows:

```yml
on:
  repository_dispatch:
    types: [event1, event2]
```

The API endpoint is https://api.github.com/repos/{owner}/{repo}/dispatches, and you provide the event type in the following way:

```sh
curl \
  -X POST \
  -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/{owner}/{repo}/dispatches \
  -d '{"event_type":"event1"}'
```

You can also pass in additional JSON as a `client_payload`:

```json
{
  "event_type": "event1"
  "client_payload": {
    "passed": false,
    "message": "Error: timeout"
  }
}
```

The payload can then be accessed via the github.event context:

```yml
- run: |
    echo "Payload: ${{ toJSON(github.event.client_payload) }}"
  name: Payload
  if: ${{ github.event_name == 'repository_dispatch' }}
```

There are several ways you can call the GitHub API. You can use `curl`, like in the preceding example. You can use the GitHub CLI:

```sh
gh api -X POST -H "Accept: application/vnd.github.v3+json" \
  /repos/{owner}/{repo}/dispatches \
  -f event_type=event1 \
  -f 'client_payload[passed]=false' \
  -f 'client_payload[message]=Error: timeout'
```

There is also an SDK for many programming languages, called `octokit`. For example, you can call the dispatch API in JavaScript:

```js
await octokit.request('POST /repos/{owner}/{repo}/dispatches', {
  owner: '{owner}',
  repo: '{repo}',
  event_type: 'event1'
  client_payload: {
    passed: "false",
    message: "Error: timeout",
  },
})
```

If you want to learn more on working with the GitHub API, please refer to the [documentation][2].

Workflow triggers are very important. If you choose the right triggers and configure them correctly, you need less-complex workflow logic. But before we learn more about expressions and context, we should first have a look at the main workflow elements: workflow jobs and steps.

## 3.4 Workflow jobs and steps

The logic of the workflow is configured in the jobs section. Every job is executed on a *runner*. The runner can be self-hosted, or you can pick one from the cloud. There are different versions available in the cloud for all platforms. If you want to always use the latest version, you can use `ubuntu-latest`, `windows-latest`, or `macos-latest`. You’ll learn more about runners in chapter 5.

### 3.4.1 Workflow jobs

*Jobs* are a YAML map—not a list—and they run in parallel by default. You can chain them in a sequence by having a job depend on the successful output of one or multiple other jobs, using the `needs` keyword. The following listing shows an example of four jobs—two that run in parallel after the first job and a final one that runs after the two parallel jobs have finished.

**Listing 3.4 Chaining of jobs**

```yml
jobs:
  job_1:
    runs-on: ubuntu-latest
    steps:
      - run: "echo Job: ${{ github.job }}"
  
  job_2:
    runs-on: ubuntu-latest
    needs: job_1
    steps:
      - run: "echo Job: ${{ github.job }}"
  
  job_3:
    runs-on: ubuntu-latest
    needs: job_1
    steps:
      - run: "echo Job: ${{ github.job }}"
  
  job_4:
    runs-on: ubuntu-latest
    needs: [job_2, job_3]
    steps:
      - run: "echo Job: ${{ github.job }}"
```

The resulting workflow would look like that shown in figure 3.4.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F04_Kaufmann.png)<br>
**Figure 3.4 A visual representation of chained workflow jobs in GitHub**

### 3.4.2 Workflow steps

A job contains a sequence of steps, and each step can run a command. Steps are always executed one after the other:

```yml
steps:
  - name: Install Dependencies
    run: npm install
  - run: npm run build
```

The `name` property is optional and defines how the step is displayed in the workflow log.

Literal blocks allow you to write multiline scripts in one workflow step. If you want the workflow to run in a different shell than the default shell, you can configure it together with other values, like the `working-directory`:

```yml
- name: Clean install dependencies and build
  run: |
    npm install
    npm run build
  working-directory: ./temp
  shell: bash
```

The shells shown in table 3.2 are available.

**Table 3.2 Shells available in GitHub workflows**

| **Parameter** | **Description**                                                                                                                                         |
|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------------|
| `bash`        | Bash shell. The default shell on all non-Windows platforms with a fallback to sh. When specified on Windows, the bash shell included with Git is used.  |
| `pwsh`        | PowerShell Core. Default on the Windows platform.                                                                                                       |
| `python`      | The Python shell—allows you to run python scripts                                                                                                       |
| `cmd`         | Windows only! The Windows command prompt.                                                                                                               |
| `powershell`  | Windows only! The classic Windows PowerShell.                                                                                                           |

Windows only! The classic Windows PowerShell.

The default shell on non-Windows systems is `bash` with a fallback to `sh`. The default on windows is `pwsh` with a fallback to `cmd`.

You can also configure a custom shell with the with the syntax `shell: command [options] {0}`. The placeholder `{0}` will be replaced with the script you provide. Here is an example for running a `perl` script:

```yml
- run: print %ENV
  shell: perl {0}
```

You will learn more about shells in chapter 5.

### 3.4.3 Using GitHub actions

Most of the time, you want to use reusable steps, called *GitHub actions*. You can reference an action using the uses keyword and the following syntax:

```yml
{owner}/{repo}@{ref}
```

The `{owner}/{repo}` is the path to the actions repository in GitHub. If you have multiple actions in a repository, the syntax is the following:

```yml
{owner}/{repo}/{path}@{ref}
```

But in this case, the action cannot be published to the marketplace.

The reference `{ref}` is the version of the action. It is a Git reference to the point in time in the history of changes. The reference can be all kinds of valid Git references, including *a tag*, *a branch*, or an individual *commit* referenced by its SHA-1 value. The most common is using tags for explicit versioning with major and minor versions:

```yml
- uses: actions/checkout@v3                                       # ❶
- uses: actions/checkout@v3.5.2
  
- uses: actions/checkout@main                                     # ❷
  
- uses: actions/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab # ❸
# ❶ References a version using a tag
# ❷ References the current head of a branch
# ❸ References a specific commit
```

If your action is in the same repository as the workflow, you can use a relative path to the action:

```yml
uses: ./.github/actions/my-action
```

If the action has defined inputs, you can specify them using the `with` property:

```yml
- name: My first Action step
  uses: ActionsInAction/HelloWorld@v1
  with:
    WhoToGreet: Mona
```

Inputs can be optional or required. You can also set environment variables for steps using the `env` property:

```yml
- uses: ActionsInAction/HelloWorld@v1
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    WhoToGreet: Mona
```

You can also set variables for the entire workflow or a job, and they will automatically be available to the action.

Every `docker` container stored in a container registry, like Docker Hub or GitHub Packages, can be used as a step in the workflow using the syntax `docker://{image}:{tag}`:

```yml
uses: docker://alpine:3.8
```

This is very handy if you want to integrate existing solutions in Docker into your workflows. The only limitation is that the container registry must be accessible for the workflow without credentials. In chapter 4, you will learn how to author GitHub actions, and you will learn how they work internally.

### 3.4.4 The matrix strategy

Jobs can be run with different configurations, using the matrix strategy. The matrix can be a one-dimensional array and the workflow will execute one job for each value in the array. Furthermore, the matrix can consist of multiple arrays, and the workflow will execute a job for all combinations of all values in the matrix. You can think of this as nested for loops over all arrays.

The keys in the matrix can be anything, and you refer to them using the expression `${{ matrix.key }}`. You can choose whether the matrix should abort execution when an error occurs in one of the jobs in the matrix or if it should continue executing the other jobs, using the `fail-fast` property. The maximum number of jobs that run in parallel can be set using max-parallel. The following listing shows an example that will run the same job for the NodeJS versions 12, 14, and 16 on Ubuntu and macOS.

**Listing 3.5 Executing jobs with different configurations**

```yml
jobs:
  job_1:
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        os_version: [macos-latest, ubuntu-latest]
        node_version: [12, 14, 16]
  
    name: My first job
    runs-on: ${{ matrix.os_version }}
    steps:
      - uses: actions/setup-node@v3.6.0
        with:
          node-version: ${{ matrix.node_version }}
```

This code will result in six jobs with all combinations, and the workflow output will look like that shown in figure 3.5. The job name will be suffixed with the values of the matrix.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F05_Kaufmann.png)<br>
**Figure 3.5 The output of a job with multiple configurations**

It is also possible to include or exclude some values for specific configurations. Please refer to https://mng.bz/EOVo for the latest documentation.

## 3.5 Expressions and contexts

You have already seen some expressions in the first hands-on example, when we had a look at manual triggers and the matrix strategy. An expression has the following syntax:

```yml
${{ <expression> }}
```

Expressions can access context information and combine them with operators. There are different objects available that provide context information, like `matrix`, `github`, `env`, `vars`, `needs`, `runner`, or `input`. With `github.sha`, for example, you can access the commit SHA that had triggered the workflow. With runner.os, you can get the operating system of the runner, and with `env`, you can access environment variables. For a complete list of context objects and all properties, please refer to https://mng.bz/NB8N.

There are two possible syntaxes to access context properties:

```yml
context['key']
context.key
```

The latter, the property syntax, is more common.

Depending on the format of the key, you might have to use the first option. This might be the case if the key starts with a number or contains special characters other than dash (`-`) and underscore (`_`).

Expressions are often used in the `if` object to run jobs or steps on different conditions. The following example will only execute the job deploy if the workflow was triggered by a push to `main`:

```yml
jobs:
  deploy:
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - run: echo "Deploying branch ${{ github.ref }}"
```

The expression must return `true` or `false` and can be used on steps and jobs to control the flow of the workflow by conditionally executing them. To write expressions and compare context with static values, you can use the operators from table 3.3.

**Table 3.3 Operators for expressions**

| **Operator** | **Description**                      |
|--------------|--------------------------------------|
| ( )          | Logical grouping                     |
| [ ]          | Index                                |
| .            | Property dereference                 |
| !            | Not                                  |
| <, <=        | Less than, less than or equal        |
| >, >=        | Greater than, greater than or equal  |
| ==           | Equal                                |
| !=           | Not equal                            |
| &&           | And                                  |
| ||           | Or                                   |

GitHub offers a set of built-in functions that you can use in expressions. They can help you searching in strings, formatting output, or working with arrays. See table 3.4 for a list of available functions.

**Table 3.4 Built-in functions in GitHub for expressions**

| **Function**                   | **Description**                                                                                                                                                                             | **Examples**                                                                                 |
|--------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|
| contains (search, item)        | Returns true if search contains item                                                                                                                                                        | contains('Hello world', 'llo') returns true.contains(github.event.                           |
|                                |                                                                                                                                                                                             | issue.labels.*.name, 'bug') returns true if the issue related to the event has a label bug.  |
| startsWith (search, iten)      | Returns true when search starts with item                                                                                                                                                   |                                                                                              |
| endsWith (search, item)        | Returns true when search ends with item                                                                                                                                                     |                                                                                              |
| format (string, v0, v1, ...)   | Replaces values in the string                                                                                                                                                               | format('Hello {0} {1} {2}', 'Mona', 'the', 'Octocat') returns 'Hello Mona the Octocat'.      |
| join (array, optS)             | All values in array are concatenated into a string. If you provide the optional separator optS, it is inserted between the concatenated values. Otherwise, the default separator , is used. |                                                                                              |
| toJSON(value)                  | Returns a pretty-print JSON representation of value                                                                                                                                         |                                                                                              |
| fromJSON(value)                | Returns a JSON object or JSON data type for value                                                                                                                                           |                                                                                              |
| hashFiles(path)                | Returns a single hash for the set of files that matches the path pattern                                                                                                                    |                                                                                              |

There are also some special functions to check the status of the current job. In the following example, the step displayed would only be executed if a previous step of the jobs has failed:

```yml
steps:
  ...
  - name: The job has failed
    if: ${{ failure() }}
```

For a list of available functions to check the status of the job, see table 3.5.

**Table 3.5 Functions to check status of the workflow job**

| **Function**  | **Description**                                                                                       |
|---------------|-------------------------------------------------------------------------------------------------------|
| `success()`   | Returns true if none of the previous steps have failed or been cancelled                              |
| `always()`    | Returns true even if a previous step was cancelled and causes the step to always get executed anyway  |
| `cancelled()` | Returns only true if the workflow was canceled                                                        |
| `failure()`   | Returns true if a previous step of the job had failed                                                 |

You can use the `*` syntax to apply object filters for arrays and objects. Assume you have an array of objects called *fruits* with the following values:

```yml
fruits=[
  { "name": "apple", "quantity": 1 },
  { "name": "orange", "quantity": 2 },
  { "name": "pear", "quantity": 1 }
]
```

The filter `fruits.*.name` returns the array `["apple", "orange", "pear"]`, and the filter `fruits.*.quantity` returns `[1, 2, 1]`.

Expressions are a powerful way to control the flow and execution of your workflow. You will learn more about these via examples in the rest of the book.

## 3.6 Workflow commands

Workflow steps and actions can communicate with the workflow and the runner machine using *workflow commands*. They can be used to write messages to the workflow log, pass values to other steps or actions, set environment variables, or write debug messages.

Workflow commands use the `echo` command with a specific format, or they are invoked by writing to a specific environment file:

```yml
echo "::workflow-command parameter1={data},parameter2={data}::{command value}"
```

If you are using JavaScript, the *toolkit* (https://github.com/actions/toolkit) provides a lot of wrappers that can be used instead of using `echo` to write to `stdout`. For example, if you want to log an error to the workflow log, you can use the following echo command:

```yml
- run: echo "::error file=app.js,line=1::Missing semicolon"
```

With the toolkit, you can achieve the same in the following form:

```yml
core.error('Missing semicolon', {file: 'app.js', startLine: 1})
```

For a complete list of available workflow commands, please refer to the documentation: https://mng.bz/Dp1n. In the following sections, you will learn some examples of useful workflow commands.

### 3.6.1 Writing a debug message

You can print a debug message to the workflow log. To see the debug messages set by this command in the log, you must create a variable named `ACTIONS_STEP_DEBUG` with the value `true`. You will learn later in this chapter how to set variables. The syntax is

```yml
::debug::{message}
```

Debug messages are extremely useful to debug your workflows without cluttering the log if you are not debugging.

### 3.6.2 Creating error or warning messages

You can create warning and error messages and print them to the log in the same way. The messages will create an annotation, which can associate the message with a particular file in your repository. Optionally, your message can specify a position within the file:

```yml
::warning file={name},line={line},endLine={el},title={title}::{message}
::error file={name},line={line},endLine={el},title={title}::{message}
```

The parameters are the following:

* `title`—A custom title for the message
* `file`—The filename that raised the error or warning
* `col`—The column/character number, starting at 1
* `endColumn`—The end column number
* `line`—The line number in the file starting with 1
* `endLine`—The end line number

The following is an example of how these two commands can be used:

```yml
echo "::warning file=app.js,line=1,col=5,endColumn=7::Missing semicolon"
echo "::error file=app.js,line=1,col=5,endColumn=7::Error in app.js"
```

You can see the output of these commands in the log in figure 3.6. The annotations will be added to the workflow overview page, and the link to the file is clickable (see figure 3.7).

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F06_Kaufmann.png)<br>
**Figure 3.6 Warning and error messages in the workflow log**

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F07_Kaufmann.png)<br>
**Figure 3.7 Annotations in the workflow overview page**

The link will redirect you to the corresponding line in the file if it is part of the source commit of the workflow. If the workflow is associated with a pull request, then you can see the messages on the correct lines in the Files Changed tab (see figure 3.8).

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F08_Kaufmann.png)<br>
**Figure 3.8 Warning and error messages shown as pull request decorations**

### 3.6.3 Passing an output to subsequent steps and jobs

The syntax to pass output values to subsequent tasks is different. Instead of using a workflow command with `echo`, you have to pipe a name–value pair to the *environment* file `$GITHUB_OUTPUT`:

```yml
echo "{name}={value}" >> "$GITHUB_OUTPUT"
```

The operator `>>` appends the name–value pair to the end of the file. The path and filename of the file are stored in the environment variable `$GITHUB_OUTPUT`. You can access the output using the output property of the step in the steps context:

```yml
- name: Set color
  id: color-generator
  run: echo "SELECTED_COLOR=green" >> "$GITHUB_OUTPUT"
- name: Get color
  run: echo "${{ steps.color-generator.outputs.SELECTED_COLOR }}"
```

Outputs are Unicode strings and cannot exceed 1 MB in size. The total of all outputs in a workflow run cannot exceed 50 MB.

If you want to mask the output in the log, even when you pass the value to other steps or jobs, you can use `::add-mask::{value}`. This will mask the output in the log. The value will be preserved—only the output is masked. You can find an example in the following listing.

**Listing 3.6 Masking secret values across multiple steps**

```yml
on: push
jobs:
  generate-a-secret-output:
    runs-on: ubuntu-latest
    steps:
      - id: sets-a-secret
        name: Generate, mask, and output a secret
        run: |
          the_secret=$((RANDOM))
          echo "::add-mask::$the_secret"
          echo "secret-number=$the_secret" >> "$GITHUB_OUTPUT"
      - name: Use that secret output (protected by a mask)
        run: |
          echo "the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}"
```

### 3.6.4 Environment files

During the execution of a workflow, the runner generates temporary files that you can manipulate to perform certain actions—the output file is one example. The paths to these files are exposed via environment variables—in this case, `$GITHUB_OUTPUT`.

Another use case for environment files is setting an environment variable for subsequent steps in a job. The corresponding environment file is `$GITHUB_ENV`. And again, you just append another name–value pair to the end of the file:

echo "{environment_variable_name}={value}" >> "$GITHUB_ENV"
Note that the name is case sensitive! The following is a complete example of how to set an environment variable in one step and access it in a subsequent step, using the env context:

```yml
steps:
  - name: Set the value
    id: step_one
    run: |
      echo "action_state=yellow" >> "$GITHUB_ENV"
  
  - run: |
      echo "${{ env.action_state }}" # This will output 'yellow'
```

For a complete reference on environment files, please refer to the documentation at: https://mng.bz/lr26. Another example for environment files is adding a job summary in a workflow.

## 3.6.5 Job summaries

You can set some custom Markdown for each workflow job. The rendered Markdown will then be displayed on the summary page of the workflow run. You can use job summaries to display content, such as test or code coverage results, so that someone viewing the result of a workflow run doesn’t need to go into the logs or an external system.

Job summaries support GitHub Flavored Markdown. But since Markdown is HTML, you can also output HTML to the job summary file.

Add results from your step to the job summary by appending Markdown to the following file:

```yml
echo "{markdown content}" >> $GITHUB_STEP_SUMMARY
```

The steps are isolated and restricted to 1 MiB (1.04858 MB). They are isolated so that malformed Markdown from a single step cannot break Markdown rendering for subsequent steps. Only 20 steps can write to the summary, and the output of any step after that will not be visible.

Here is an example that adds Markdown and plain HTML to the job summary:

```yml
- run: echo '### Hello world! :rocket:' >> $GITHUB_STEP_SUMMARY
- run: echo '### Love this feature! :medal_sports:' >> $GITHUB_STEP_SUMMARY
- run: echo '<h1>Great feature!</h1>' >> $GITHUB_STEP_SUMMAsRY
```

The result looks like figure 3.9.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F09_Kaufmann.png)<br>
**Figure 3.9 Markdown and HTML displayed on the workflow summary page**

If you have more complex scenarios or you are authoring your action in JavaScript anyway, then you can use the *toolkit* (https://github.com/actions/toolkit) function `core.summary` to write tables or links. The following listing shows an example of that.

**Listing 3.7 Writing a job summary using the toolkit**

```yml
- name: Write Summary from Action
  uses: actions/github-script@v6.1.0
  with:
    script: |
      await core.summary
      .addHeading('Test Results')
      .addTable([
        [{data: 'File', header: true}, {data: 'Result', header: true}],
        ['foo.js', 'Pass ✅'],
        ['bar.js', 'Fail ❌'],
        ['test.js', 'Pass ✅']
      ])
      .addLink('View staging deployment!', 'https://github.com')
      .write()
```

The result will look like that in figure 3.10.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F10_Kaufmann.png)<br>
**Figure 3.10 A job summary created by the toolkit**

## 3.7 Secrets and variables

You can create configuration variables to use across multiple workflows by defining them on one of the following levels:

* Organization level
* Repository level
* Environment level

The three levels work like a hierarchy: you can override a variable or secret on a lower level by providing a new value to the same key. Figure 3.11 illustrates the hierarchy.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F11_Kaufmann.png)<br>
**Figure 3.11 The hierarchy for configuration variables and secrets**

*Secrets* are a special form of configuration variables. They are encrypted when stored and are only decrypted at run time. They are also protected and masked in the workflow log.

Secrets can be accessed using the `secret` context and variables using the `vars` context. Here is an example of how you can pass secrets and variables to a GitHub action:

```yml
- name: Set secret and var as input
  uses: ActionsInAction/HelloWorld@v1
  with:
    MY_SECRET: ${{ secrets.secret-name }}
    MY_VAR: ${{ vars.variable-name }}
```

Secrets and variables can be set using the UI or CLI by users with the admin role. In the UI, you can do this under `Settings > Secrets` and `Variables > Actions` on the corresponding hierarchy level. In a repository, you can set secrets with write access, but you have to use the CLI to do so, as you have no access to the settings. There, you can switch between the Secrets and Variables tabs, and you will find the New Repository Secret button (**Settings > Secrets > Actions > New**) or New Repository Variable button (**Settings > Variables > Actions > New**), which you can use to create new entries (see figure 3.12). When creating secrets or variables, it’s important to remember the naming conventions for secrets and variables.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F12_Kaufmann.png)<br>
**Figure 3.12 Setting secrets and variables using the GitHub UI**

Naming conventions for secrets and variables

Secret names are not case sensitive, and they can only contain normal characters ([a-z] and [A-Z]), numbers ([0-9]), and underscores (_). They must not start with GITHUB_ or a number. The best practice is to name the secrets with uppercase words separated by an underscore character.

Secrets and variables for organizations work the same way. Create the secret or variable under Settings > Secrets and Variables > Actions. New organization secrets or variables can have an access policy to any of the following:

* All repositories
* Private repositories
* Selected repositories

When choosing Selected Repositories, you can grant access to individual repositories.

If you prefer the GitHub CLI, you can use `gh secret` or `gh variable` to create new entries:

```sh
gh secret set secret-name
gh variable set var-name
```

You will be prompted for the secret or variable value, or you can read the value from a file, pipe it to the command, or specify it as the body (`-b` or `--body`):

```sh
gh secret set secret-name < secret.txt
gh variable set var-name --body config-value
```

If the entry is for an environment, you can specify it using the `--env` (`-e`) argument. For organization secrets, you set the visibility (`--visibility` or `-v`) to all, private, or selected. For selected, you must specify one or more repos, using `--repos` (`-r`):

```sh
gh secret set secret-name --env environment-name
gh secret set secret-name --org org -v private
gh secret set secret-name --org org -v selected -r repo
```

## 3.8 Workflow permissions

The `GITHUB_TOKEN` is a special secret. It is automatically created by GitHub and can be accessed through the github context (`github.token`) or the secrets context (`secrets.GITHUB_TOKEN`). The token can be accessed by a GitHub action, even if the workflow does not provide it as an input or environment variable. You can use this token to authenticate the workflow when accessing GitHub resources. The default permissions can be set to permissive (`read and write`) or restricted (`read only`), but they can be adjusted in the workflow. You can see the workflow permissions in the workflow log under Set up **Job > GITHUB_TOKEN** Permissions. It is best practice to always explicitly set the permissions your workflow needs; all other permissions will be set to `none` automatically. The permissions can be set for an individual job or for the entire workflow.

The following is an example of a workflow that will apply labels to pull requests depending on the files that are changed. The workflow needs read permissions for content to `read` the configuration, and it needs `write` permissions for pull requests to apply the label. All other permissions will be `none`:

```yml
on: pull_request_target
  
permissions:
  contents: read
  pull-requests: write
  
jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/labeler@v5
```

Actions performed with the `GITHUB_TOKEN` will appear in the history as having been performed by the *github-actions* bot (see figure 3.13). They also will not trigger new workflow runs, to avoid infinite loops by recursive workflow runs.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F13_Kaufmann.png)<br>
**Figure 3.13 Actions performed with the GITHUB_TOKEN will appear in the log as having been performed by the github-actions bot.**

The default access for the `GITHUB_TOKEN` is `restricted`. This grants `read` permission for contents and metadata. You could set the default to `read and write`, but it is recommended to restrict this setting and grant permissions on the workflow or job level. In chapter 10, you’ll learn more about the security implications of the permissions for the `GITHUB_TOKEN`.

When authoring a workflow, you should be aware of the necessary permissions. You should also keep in mind what will happen when the workflow runs from a fork. Private repositories can configure regardless of whether pull requests from forks are able to run workflows. The maximum permissions for the `GITHUB_TOKEN` in workflows triggered from a fork will always be read for all individual permissions.

## 3.9 Authoring and debugging workflows

The workflow designer is a great help when authoring workflows, as you have experienced in chapter 2. Autocomplete, error checking, and the integration of the documentation and the marketplace in the UI are a great help when writing a workflow.

If you start in a Greenfield repository, it is best to just write your workflows in the main branch. However, if you have to create the workflow in a repository developers are working in, you don’t want to get in their way. It is possible to write workflows in a branch and merge them back to the main branch using a pull request; however, some triggers might not work as expected. If you want to run your workflow manually using the `workflow_dispatch` trigger, you first must merge the workflow with the trigger back to main or use the API to trigger the workflow. After that, you can author the workflow in a branch and select the branch when triggering the workflow through the UI.

If your workflow needs webhook triggers, like `push`, `pull_request`, or `pull_request_target`, it is best to create the workflow in a fork of the repository. This way, you can test and debug the workflow without interfering with the developers work, and once you are done, you can merge it back to the original repository.

The workflow designer on the web can be very helpful when authoring GitHub Actions, but an even better experience is provided by the Visual Studio Code extension for GitHub Actions (https://mng.bz/Bg10).

The extension provides the following features:

* Managing workflows and monitoring workflow runs
* Manually triggering workflows
* Syntax highlighting for workflows and expressions
* Integrating documentation
* Validating and completing code
* Smart validation

The extension’s smart validation is an especially great help. It supports code completion for referenced actions and reusable workflows, and it parses parameters, inputs, and outputs for referenced actions and provides validation, code completion, and inline documentation. Together with GitHub Copilot, this increases quality and speed for authoring workflows tremendously. Figure 3.14 shows some of the most important features of the extension.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781633437302/files/OEBPS/Images/CH03_F14_Kaufmann.png)<br>
**Figure 3.14 The Visual Studio Code extension for GitHub Actions**

There is also a GitHub action to lint all your workflows in your repo, called `actionlint`: https://github.com/devops-actions/actionlint. It can bring many mistakes to the surface—for example, if you use potentially untrusted inputs in scripts, like the `github.head_ref`. The linter can also run on pull requests and annotate you changes in workflow files. You can add the linter as a step to your workflow after checking out the repository:

```yml
jobs:
  main:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
      - uses: devops-actions/actionlint@v0.1.9
```

In general, the best approach is to first run and debug deployment scripts locally or on a virtual machine and then move them to the workflow when you know they will work—but even then, you might experience strange behavior. If you do, you can enable debug logging by adding a variable `ACTIONS_STEP_DEBUG` to your repository and setting the value to `true`. This will add a very verbose output to your workflow log, and all debug messages from each action will be displayed. If your issue is related to a runner, you can activate additional logs the same way by setting the `ACTIONS_RUNNER_DEBUG` variable to `true`. In chapter 6, you will learn more about self-hosted runners and logging. If you want to learn more about [debug logging][3].

## 3.10 Conclusion

In this chapter, you learned the basics of YAML and the workflow syntax you need to know to start authoring workflows. In the next chapter, you will learn how to author and share your own GitHub actions.

## Summary

* YAML is a text-based data-serialization language optimized to be directly writable and readable by humans. It is a strict superset of JSON with syntactically relevant newlines and indentation instead of braces.

* There are three types of events that can trigger workflows: webhook triggers, scheduled triggers, and manual triggers.

* Jobs run in parallel by default if they do not depend on other jobs, whereas steps run in a sequence.

* A workflow step can be a command line executed in a shell or a reusable action.

* You can store configuration variables and secrets on the organization, repository, or environment level and access them in your workflow.

* The `GITHUB_TOKEN` can be used to authenticate the workflow when accessing GitHub resources, and you can set the permissions in a job or workflow.

* You can author your workflows in a branch, but sometimes it’s a better approach to create the workflow in a fork to avoid causing problems when developing your application.

[1]: https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows
[2]: https://docs.github.com/en/rest/using-the-rest-api/getting-started-with-the-rest-api
[3]: https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging