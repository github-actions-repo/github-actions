# Building GitHub Actions

Now that you’ve learned how to author workflows and already used some actions from the marketplace, it is time to fully understand what actions are and how they work. In this chapter, I will explain the different types of actions and we will cover the following recipes so that you know how to write actions yourself:

> * Creating a Docker container action
> * Adding output parameters and using job summaries
> * Creating a TypeScript action
> * Creating a composite action
> * Sharing actions to the marketplace
> * Best practices for developing custom actions

You will learn how to pass in parameters to actions and use output parameters in subsequent workflow steps. You will also learn how to write to the workflow log and annotate changes in files from within the action and how to create rich job summaries.

---

## Technical requirements

In the following recipes, I’ll be using VS Code. You’ll need a version of that and a local git client to follow along.

If you want to run the Docker image that we provision as an action locally, you will also need Docker installed on your machine. You could also use GitHub Codespaces if you want.

For the TypeScript action, you’ll need to have a reasonably modern version of Node.js installed. If you are using a version manager such as `nodenv` or `nvm`, you can run `nodenv install` in the root of your repository to install the version specified in `package.json`. Otherwise, 20.x or later should work. Check the `README.md` file at https://github.com/actions/typescript-action for updated requirements. If you don’t want to install Node.js, just use GitHub Codespaces for that recipe.

---

## Creating a Docker container action

In this recipe, you will create a simple **Docker container action** from a Dockerfile and use it in a **continuous integration (CI)** workflow that will run the action from within the workflow every time you change something.

### Getting ready...

Create a new repository called DockerActionRecipe. Make it public so that you don’t consume any action minutes and initialize it with a README file (see Figure 3.1):


Figure 3.1 – Creating a new repository for the Docker container action

Clone the repository locally and open it in VS Code or GitHub Codespaces.

### How to do it...

Create a new file called Dockerfile in the root of the repository. Add the following content to the file:

```Dockerfile
# Container image that runs your code
FROM alpine:latest
CMD echo "Hello World"
```

This will create an image based on the latest Alpine image and add a layer that writes “Hello World” to the console.

Run the Docker container locally with the following command:

```sh
docker run $(docker build -q .)
```

It will create an image (docker build) and run it (docker run). You should be able to see Hello World on the console.

To be more flexible, let’s move our script code to its own file. Create a new file called entrypoint.sh and add the following content:

```sh
#!/bin/sh -l
echo "Hello World"
```

Now, adjust the Dockerfile so that it executes the script instead of directly writing to the console. Copy the script file to the root of the container, and then use it as the entry point:

```Dockerfile
FROM alpine:3.10
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
```

Note that I added the chmod +x entrypoint.sh command to make the script executable. Otherwise, if you try to run the container locally, it will fail, with a message stating exec: "/entrypoint.sh": permission denied. On all Unix-based systems, you can just run chmod +x entrypoint.sh locally, and the attribute will be attached to the file when committing to git. On Windows, you can use git to set the file permissions:

```sh
git add entrypoint.sh
git update-index --chmod=+x entrypoint.sh
```

Run the Docker container again. You should see Hello World again – this time from the script file:

```sh
docker run $(docker build -q .)
```

In the action, we want to make use of an input parameter. That’s why we are going to parameterize the script. Replace the word World with the arguments that were passed to Docker ($@ for all arguments):

```sh
#!/bin/sh -l
echo "Hello $@"
```

Try to run the container again locally and pass in some words. The container will print the result, as follows:

```sh
docker run $(docker build -q .) foo bar
> Hello foo bar
```

Next, add a new file to your repository called action.yml and add the following input:

```yml
name: 'Docker Action Recipe'
description: 'Greet someone'
inputs:
  who-to-greet:
    description: 'Who to greet'
    required: true
    default: 'World'
  runs:
    using: 'docker'
    image: 'Dockerfile'
    args:
      - ${{ inputs.who-to-greet }}
```

At this point, the action is ready. To test it, we’ll add a local workflow file called .github/workflows/ci.yml that will run on every push. It will download the repository and execute our action with a custom input parameter:

```yml
name: Action CI
on: [push]
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4.1.1
      - name: Run my own container action
        uses: ./
        with:
          who-to-greet: '@wulfland'
```

Referencing local actions

Note that we are referencing the action by the local path, ./ – that’s the reason why we have to use the checkout action first. The workflow will use the same version the workflow runs on. You could also reference the action normally by specifying <owner>/DockerActionRecipe@main – the same way you would reference it from another repository.

Commit and push all your changes. The push trigger will automatically run your workflow and you can inspect the output of your action. It should look like what’s shown in Figure 3.2:

Figure 3.2 – Output of your action in the workflow

Check the output of the action via the Docker daemon and the parameter that was passed to the action.

### How it works...

There are three different types of actions:

Docker container actions
JavaScript actions
Composite actions
Docker container actions run on Linux only, whereas JavaScript actions and Composite actions can be used on any platform.

All actions are defined by a file called action.yml (or action.yaml) that contains the metadata that defines the action. This file cannot be named differently, meaning an action must reside in its own repository or folder. The run section in the action.yml file defines what type of action it is.

Docker container actions contain all their dependencies in the container and are therefore very consistent. They allow you to develop your actions in any language – the only restriction is that it must run on Linux. Docker container actions are slower than JavaScript actions because of the time it takes to retrieve or build the image and start the container.

Docker container actions can reference an image in a container registry, such as Docker Hub or GitHub Packages, or it can build a Dockerfile at runtime that you provide with the other action files. In this case, you must specify Dockerfile as the image name in the action.yml file.

### There’s more...

Container actions are very powerful as you can write them in any language. You can return output parameters to your workflow, write messages to the workflow log, annotate files in pull requests, and write rich job summaries. In the next short recipe, we’ll add output parameters and write to the job summary.

Adding output parameters and using job summaries
In this recipe, we’ll add an output parameter to the action that can be used in subsequent steps, and we are going to write content to the workflow job summary.

### Getting ready...

You will have to finish the previous recipe to continue with this one.

### How to do it...

Open the action.yml file and add the following code right under the inputs section but before the runs section:

```yml
outputs:
  answer:
    description: 'The answer to everything (always 42)'
```

This defines one output with an ID of answer.

Next, open entrypoint.sh and add the following line to the end of the file:

```sh
echo "answer=42" >> $GITHUB_OUTPUT
```

This will set the output value for answer to 42.

Now, add the following lines to the end of entrypoint.sh to write some Markdown and HTML to the step summary:

```sh
echo "### Hello $@! :rocket:" >> $GITHUB_STEP_SUMMARY
echo "<h3> The answer from Deep Thought is 42 :robot:</h3>" >> $GITHUB_STEP_SUMMARY
```

Before we commit the changes, we must adjust the workflow file, .github/workflows/ci.yml, so that it uses the output parameter. Add an ID of my-action to the step that executes our action, like this:

```yml
- name: Run my own container action
  id: my-action
  uses: ./
  with:
    who-to-greet: '@wulfland'
```

Add another step that outputs the result to the workflow log:

```yml
- name: Output the answer
  run: echo "The answer is ${{ steps.my-action.outputs.answer }}"
```

To fail the CI build when an unexpected result is returned from the Docker container action, we must add a new step that only gets executed when the result is not expected. Returning a non-zero value (for example, exit 1) will indicate to the workflow that the step has failed. We can use file annotation to indicate where the error is (the same way we did in Chapter 2):

```yml
- name: Test the container
  if: ${{ steps.my-action.outputs.answer != 42 }}
  run: |
    echo "::error file=entrypoint.sh,line=4,title=Error in container::The answer was not expected"
    exit 1
```

Commit and push all your changes. The build will run automatically and should succeed. Inspect the workflow log and ensure the output parameter was passed to the next steps correctly (see Figure 3.3):

Figure 3.3 – The output of the Docker container action

Also, take a look at the job summary on the summary page, which has rendered our Markdown/HTML (see Figure 3.4):


Figure 3.4 – Job summary on the workflow summary page

Finally, we want to ensure that our CI build fails if an unexpected value is returned. Open entrypoint.sh and change 42 to something different (for example, 7).
Switch to another branch, commit and push, and create a new pull request:

```sh
git switch -c fail-ci-build
git commit -m "Fail CI build"
git push -u origin fail-ci-build
gh pr create --fill
```

The checks for the pull request will fail, and it will annotate the corresponding file (see Figure 3.5):


Figure 3.5 – The CI build will fail the pull request if the output is unexpected

Note how GitHub marks the change and annotates the exact line.

### How it works...

Let’s understand how the code works.

Environment files
Passing output values to subsequent steps and jobs works by piping a name-value pair to the environment file – that is, $GITHUB_OUTPUT:

```sh
echo "{name}={value}" >> "$GITHUB_OUTPUT"
```

The >> operator appends the name-value pair to the end of the file. The path and filename of the file are stored in the $GITHUB_OUTPUT environment variable. You can access the output using the output property of the step in the steps context:

```sh
"${{ steps.<step-id>.outputs.<name> }}"
```

Outputs are Unicode strings and cannot exceed 1 MB in size. The total of all outputs in a workflow run cannot exceed 50 MB.

Another use case for environment files is setting environment variables for subsequent steps in a job. The path to the corresponding environment file is stored in $GITHUB_ENV. You just append another name-value pair to the end of the file, like this:

```sh
echo "{environment_variable_name}={value}" >> "$GITHUB_ENV"
```

Note that the name is case-sensitive! Here is a complete example of how to set an environment variable in one step and access it in a subsequent step using the env context:

```yml
steps:
  - name: Set the value
    id: step_one
    run: |
      echo "action_state=yellow" >> "$GITHUB_ENV"
  - run: |
      echo "${{ env.action_state }}" # This will output 'yellow'
```

Job summaries
You can set custom Markdown for each job in a workflow. The rendered Markdown will be displayed on the summary page of the workflow run. Job summaries can be used to display content, such as test or code coverage results, so that someone viewing the result of a workflow run doesn’t need to go into the logs or an external system.

Job summaries support GitHub-flavored markdown. But since Markdown is HTML, you can also output HTML to the job summary file. Note that in this recipe, my GitHub username, @wulfland, is a link to my profile with a preview and that all the GitHub emojis are supported.

Adding results from your step to the job summary can be achieved by appending Markdown to the following file:

```sh
echo "{markdown content}" >> $GITHUB_STEP_SUMMARY
```

The steps are isolated and restricted to 1 MiB (1.04858 MB) so that malformed Markdown from a single step cannot break Markdown rendering for subsequent steps. Only 20 steps can be written to the summary; the output of any step after that will not be visible.

In the next recipe, we will use the toolkit to write more complex things to job summaries.

For a complete reference on environment files and job summaries, please refer to https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions?tool=bash#environment-files.

Expressions and conditional execution
We used expressions (${{ ... }}) in Chapters 1 and 2 to output values from context objects. In this recipe, we used an expression with the if property of a step to conditionally execute it:

```yml
- name: Test the container
  if: ${{ steps.my-action.outputs.answer != 42 }}
```

This step will only be executed if the value of an output answer of an action with an ID of my-action in the steps context does not equal 42.

The if property also exists for jobs to conditionally execute these as well.

When you use expressions in an if property, you can, optionally, omit the ${{ }} expression syntax because GitHub Actions automatically evaluates the if condition as an expression.

For conditional execution, the expression must return true or false. To write expressions and compare context with static values, you can use the operators provided in Table 3.1:

| **Operator** | **Description**                         |
|--------------|-----------------------------------------|
| `( )`        | Logical grouping                        |
| `[ ]`        | Index                                   |
| `.`          | Property de-reference                   |
| `!`          | Not                                     |
| `< , <=`     | Less than, less than or equal to        |
| `> , >=`     | Greater than, greater than or equal to  |
| `==`         | Equal                                   |
| `!=`         | Not equal                               |
| `&&`         | And                                     |
| `||`         | Or                                      |

Table 3.1 – Operators for expressions

GitHub offers a set of built-in functions that you can use in expressions. They can help you search strings, format output, or work with arrays. See Table 3.2 for a list of available functions:

| **Function**                  | **Description**                                                                                                                                                                                     |
|-------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `contains(search, item)`      | Returns `true` if `search` contains `item`.                                                                                                                                                         |
|                               | Examples:                                                                                                                                                                                           |
|                               | `contains('Hello world', 'llo') returns true.`                                                                                                                                                      |
|                               | `contains(github.event.issue.labels.*.name, 'bug')` returns `true` if the issue related to the event has a label bug.                                                                               |
| `startsWith(search, iten)`    | Returns `true` when `search` starts with `item`.                                                                                                                                                    |
| `endsWith(search, item)`      | Returns `true` when `search` ends with `item`.                                                                                                                                                      |
| `format(string, v0, v1, ...)` | Replaces `values` in `string`.                                                                                                                                                                      |
|                               | Example:                                                                                                                                                                                            |
|                               | `format('Hello {0} {1} {2}', 'Mona', 'the', 'Octocat')` returns `'Hello Mona the Octocat'`.                                                                                                         |
| `join(array, optS)`           | All values in `array` are concatenated into a string. If you provide the optional separator, `optS`, it is inserted between the concatenated values. Otherwise, the default separator, ,, is used.  |
| `toJSON(value)`               | Returns a pretty-print JSON representation of `value`.                                                                                                                                              |
| `fromJSON(value)`             | Returns a JSON object or JSON data type for `value`.                                                                                                                                                |
| `hashFiles(path)`             | Returns a single hash for the set of files that matches the `path` pattern.                                                                                                                         |

Table 3.2 – Built-in functions in GitHub for expressions

### There’s more...

There are also some special functions to check the status of the current job. In the following example, the last step would only be executed if a previous step of the jobs failed – meaning it returns a non-zero value:

```yml
steps:
  - run: exit 1
  - name: The job has failed
    if: ${{ failure() }}
```

For a list of available functions to check the status of the job, see Table 3.3:

| **Function**  | **Description**                                                                                           |
|---------------|-----------------------------------------------------------------------------------------------------------|
| `success()`   | Returns `true` if none of the previous steps have failed or been canceled.                                |
| `always()`    | Returns `true`, even if a previous step was canceled, and causes the step to always get executed anyway.  |
| `cancelled()` | Returns only `true` if the workflow was canceled.                                                         |
| `failure()`   | Returns `true` if a previous step of the job had failed.                                                  |

Table 3.3 – Functions to check the status of the workflow job

These functions can also help you to conditionally execute some steps and perform – for example – a cleanup. To learn more about expressions for conditional execution, please refer to https://docs.github.com/en/actions/learn-github-actions/expressions and https://docs.github.com/en/actions/using-jobs/using-conditions-to-control-job-execution.

---

## Creating a TypeScript action

In this recipe, you will create a basic **TypeScript action** from a template, build and publish it, and use it in a workflow.

### Getting ready...

Make sure you have a reasonably modern version of Node.js (https://nodejs.org/en/download) installed. Follow these steps:

1. Go to https://github.com/actions/typescript-action and click **Use this template | Create a new repository** in the top-right corner of the repository (see *Figure 3.6*):

Figure 3.6 – Creating a new repository from the typescript-action template

2. Choose your GitHub account as the owner, name it `TypeScriptActionRecipe`, leave its visibility set to **Public**, and click **Create repository**.
3. Clone the repository locally and open the folder in VS Code.

### How to do it...

Open a terminal and go to the root of the repository. Install all the necessary dependencies:

```sh
npm install
```

The repository contains some unit tests. Run them to check that everything is OK:

```sh
npm test
```

Open the `action.yml` file and update the metadata for `name`, `description`, and `author`:

```yml
name: 'TypeScript Action Recipe'
description: 'Waites for some milliseconds, writes an awesome job summary to the workflow output and returns the current date and time.'
author: 'Michael Kaufmann'
```

Ignore the branding for now – but note that the action has a defined input parameter (milliseconds) and output parameter (time):

```yml
# Define your inputs here.
inputs:
  milliseconds:
    description: 'Your input description here'
    required: true
    default: '1000'

# Define your outputs here.
outputs:
  time:
    description: 'Your output description here'
```

Open the src/main.ts file and locate the run function:

```yml
export async function run(): Promise<void> {
```

Note that it uses the toolkit (@actions/core; see https://github.com/actions/toolkit) to read the input parameter:

```yml
const ms: string = core.getInput('milliseconds')
```

It also uses the toolkit to write debug messages. This is similar to the echo "::debug::{debug message}" workflow command that we used in Chapter 2:

```yml
core.debug(`Waiting ${ms} milliseconds ...`)
```

The same is true for setting the output parameter. This is the same as writing to the GITHUB_OUTPUT environment file:

```yml
echo "answer=42" >> $GITHUB_OUTPUT
```

With the toolkit, this looks as follows:

```yml
core.setOutput('time', new Date().toTimeString())
```

The next step is to write our job summary beneath core.setOutput in the run function. Start with core.summary and note that you have auto-complete to help you with all the available functions and syntax. Add a h2 heading:

```yml
// Write an advanced job summary
core.summary
  .addHeading('Advanced Job Summary', 'h2')
```

The core.summary object has a fluent interface. This means you can add new methods directly to the output of the previous one. Add an image and set the size to 64x64:

```yml
.addImage(
  'https://octodex.github.com/images/droidtocat.png',
  'Droidtocat',
    {
      width: '64',
      height: '64'
    }
  )
```

Add a table with some data:

```yml
.addTable([
  [
    { data: 'File', header: true },
    { data: 'Result', header: true }
  ],
  ['foo.js', 'Pass '],
  ['bar.js', 'Fail '],
  ['test.js', 'Pass ']
])
```

And a simple link:

```yml
.addLink('My custom link', 'https://writeabout.net')
```

You have to finish the summary using the write function, to write the buffer to the environment file:

```yml
.write()
```

You can check the code here: https://github.com/wulfland/TypeScriptActionRecipe.

Package the TypeScript for distribution. This is an important step, and you have to do it every time you modify a .ts file!

```sh
npm run bundle
```

Commit your changes. This will automatically trigger some workflows – and while they run, you can use the time to see what they are doing..github/workflows/linter.yml runs on all push and pull requests to main and it will lint your code base:

```yml
- name: Lint Code Base
  id: super-linter
  uses: super-linter/super-linter/slim@v5
  env:
    DEFAULT_BRANCH: main
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    TYPESCRIPT_DEFAULT_STYLE: prettier
    VALIDATE_JSCPD: false
```

If this fails, then you probably forgot to run npm run bundle before committing your changes. You can also run prettier locally to make sure you adhere to the linting standards:

```sh
npx prettier . --check
npx prettier . --write
```

The.github/workflows/codeql-analysis.yml workflow will also run on every push and pull request to main – but also once a week. It will scan your code for security vulnerabilities.

Check dist (.github/workflows/check-dist.yml) is a simple workflow that will run npm run bundle and compare the output with your dist folder. It will fail if you forget to package your TypeScript using a small and simple script:

```yml
- name: Compare Expected and Actual Directories
  id: diff
  run: |
    if [ "$(git diff --ignore-space-at-eol --text dist/ | wc -l)" -gt "0" ]; then
      echo "Detected uncommitted changes after build. See status below:"
      git diff --ignore-space-at-eol --text dist/
      exit 1
    fi
```

The last one is the CI build (.github/workflows/ci.yml). It has two jobs. One installs all your dependencies and runs the unit tests, while the other executes your action and uses the output, as we did in Chapter 2:

```yml
- name: Test Local Action
  id: test-action
  uses: ./
  with:
    milliseconds: 1000
- name: Print Output
  id: output
  run: echo "${{ steps.test-action.outputs.time }}"
```

The test-typescript job will fail as we did not adjust the unit tests, but the second job should succeed. At this point, you can inspect your job summary; it should look like what’s shown in Figure 3.6:


Figure 3.7 – The job summary created using the toolkit

Also, inspect the value of the output parameter in your workflow log (see Figure 3.7):


Figure 3.8 – Output of the TypeScript action in the workflow log

Fixing the unit tests

I haven’t included a recipe for adjusting the unit tests in this book as this book is about GitHub Actions and not about TypeScript. But if you want to fix the tests, you can start by looking at the example at https://github.com/wulfland/TypeScriptActionRecipe/blob/main/__tests__/main.test.ts.

If you go back to main.ts, at the end, you will see that the action will fail if it encounters an error. It does so by using core.setFailed instead of returning a non-zero value:

```yml
} catch (error) {
    // Fail the workflow run if an error occurs
    if (error instanceof Error) core.setFailed(error.message)
  }
```

Create a new branch called fail-ci-build and switch to it:

```sh
git switch -c fail-ci-build
```

Add the following code block to the catch block before the line that contains core.setFailed:

```yml
core.error('Something bad happened', {
      title: 'Bad Error',
      file: '.github/workflows/ci.yml',
      startLine: 59,
      startColumn: 11,
      endColumn: 23
    })
```

In .github/workflows/ci.yml, modify the milliseconds argument to something that cannot be converted into an integer:

```yml
      - name: Test Local Action
        id: test-action
        uses: ./
        with:
          milliseconds: xxx
```

Package the TypeScript, commit your changes, and create a pull request:

```sh
npm run bundle
git add .
git commit -m "Fail CI build"
git push –set-upstream origin fail-ci-build
gh pr create --fill
```

Inspect the pull request you created and note the output in the log from core.setFailed and core.error (see Figure 3.9):

Figure 3.9 – Output of the failed action in the workflow log

Also, note that the annotation is displayed in the workflow file (see Figure 3.10):


Figure 3.10 – Annotations from the toolkit

The tooling around TypeScript and the toolkit make developing GitHub actions comfortable and are a great help in authoring high-quality actions.

### How it works...

TypeScript actions are not so different from container actions – they just run in a Node.js environment instead of a Docker container. TypeScript is just a layer on top of JavaScript that gets transpiled to JavaScript (into the /dist folder) if you run npm run bundle. If you are new to TypeScript, all these tools might seem overwhelming – but these tools also make it quite easy to get started. Auto-complete and IntelliSense in VS Code, automated linting and formatting, unit testing with mocking – there are a lot of tools that will help you write good code.

### There’s more...

We just have scratched the surface of what you can do with the toolkit (https://github.com/actions/toolkit). It can also help you work with the GitHub REST or GraphQL API, OICD tokens, and many more. If you plan to do more with GitHub Actions, it’s worth learning at least a little bit of Typescript to be able to leverage the power of the toolkit.

Creating a composite action
The third type of actions, besides Docker container actions and JavaScript/TypeScript actions, are composite actions. Composite actions are a wrapper for other actions. In this recipe, you will create a simple composite action and use it in a workflow – once with a bash script and once with a GitHub script.

### Getting ready...

Create a new repository called CompositeActionRecipe. Make it public so that you don’t consume any action minutes and initialize it with a README file. Clone the repository locally and open it in VS Code or open it in GitHub Codespaces.

### How to do it...

Add a new file called action.yml to the root of the repository. Add a name and description:

```yml
name: 'Composite Action Recipe'
description: 'Greets the user and returns 42.'
```

Add an input called who-to-greet and an output called answer. Note that you need the step ID to access the output. We’ll add that in the next step:

```yml
inputs:
  who-to-greet:
    description: 'Who to greet'
    required: true
    default: 'World'
outputs:
  answer:
    description: "Answer to life, the universe, and everything"
    value: ${{ steps.deep-thought.outputs.answer }}
```

Next, add the runs section, set using to composite, and add one step that executes a bash script. Note that you have to specify the shell in composite actions, and you cannot rely on the default shell:

```yml
runs:
  using: "composite"
  steps:
    - name: Awesome bash script action
      id: deep-thought
      shell: bash
      run: |
        echo "Hello '${{ inputs.who-to-greet }}'."
        echo "answer=42" >> $GITHUB_OUTPUT
        echo "So long, and thanks for all the fish."
```

We use the input to write a greeting message to the workflow log and we set the output parameter to 42 the same way we did it in the container action. The only difference is that we execute the script directly on the workflow runner and not in a container.

Add a new workflow file called .github/workflows/ci.yml and configure it so that it runs on push and pull_requests:

```yml
name: CI Workflow
on: [push, pull_request]
```

Add a job that checks out the repository and runs the composite action with an input parameter. Give the step an ID to access the output, like this:

```yml
jobs:
    ci-job:
        runs-on: ubuntu-latest
        steps:
            - uses: actions/checkout@v4.1.1
            - name: Run my own composite action
              id: my-action
              uses: ./
              with:
                who-to-greet: '@wulfland'
```

Then, add an additional step that writes the output to the console:

```yml
            - name: Output the answer
              run: echo "The answer is ${{ steps.my-action.outputs.answer }}"
```

These concepts should be already familiar from looking at the other action types.

Commit and push your changes. This will trigger the workflow; you can inspect the workflow log to see your action in action.

### How it works...

Composite actions are wrappers for steps and other actions. You can use them to bundle together multiple run commands or actions – whether you own them or they’re from the marketplace – and you can provide default values for other actions to the users in your organization.

Composite actions have steps in the runs section of the action.yml file – like you would have in a normal workflow. You can access input arguments using the inputs context. Output parameters can be accessed using the outputs context of the step in the steps context.

### There’s more...

Composite actions get executed directly on the workflow runner. Because every runner has Node.js installed, you can run JavaScript and TypeScript in a composite action as well. We will use an action called github-script to leverage the power of the toolkit in a composite action. Of course, you can also use the action directly in your workflows.

Using github-script in a composite action to add a comment to an issue
In this recipe, we will use an action called github-script to leverage the power of the toolkit inside a composite action.

### How to do it...

Remove the run step with the bash script from the action.yml file and replace it with a github-script action:

```yml
- name: Awesome github script action
  uses: actions/github-script@v6
  with:
    script: |
```

Use the toolkit to read the input parameter, write a greeting to the log, and set the output parameter. This should be familiar from the Creating a TypeScript action recipe:

```yml
var whoToGreet = core.getInput('who-to-greet')
core.notice(`Hello ${whoToGreet}`)
core.setOutput('answer', 42)
```

Now, we want to add some additional functionality. If the workflow was triggered by an issues event, then we want to add a comment to that issue. Check that the event that triggered the workflow was in fact issues and that we used github.rest.issues to create a comment:

```yml
if (context.eventName === 'issues') {
  github.rest.issues.createComment({
    issue_number: context.issue.number,
    owner: context.repo.owner,
    repo: context.repo.repo,
    body: ' Thanks for reporting!'
  })
}
```

In the CI workflow, add an additional trigger that executes the workflow when a new issue is opened:

```yml
on:
  issues:
    types: [opened]
```

Commit and push your changes.
Create a new issue in your repository under Issues | New issue (issues/new), give it a title, and save it. The workflow will run and add a comment on that issue, as shown in Figure 3.11:

Figure 3.11 – The github-script action commenting on a new issue

The github-script action is a great way to prototype things using the power of the toolkit and without the need to create a separate action.

### How it works...

The github-script action makes it easy to quickly write a script in your workflow or composite action that uses the GitHub API and the workflow run context. It uses an input named script that contains the body of an asynchronous function call. The following arguments will be provided by the action:

github: A pre-authenticated octokit/rest.js client with pagination plugins
context: An object containing the context of the workflow run
core: A reference to the @actions/core package
glob: A reference to the @actions/glob package
io: A reference to the @actions/io package
exec: A reference to the @actions/exec package
fetch: A reference to the node-fetch package
require: A proxy wrapper around the normal Node.js require to enable requiring relative paths to the current working directory and requiring npm packages to be installed in the current working directory
Since the script is just a function body, these values will already be defined, so you don’t have to import them and you can directly use them as we did with core, context, and github in our example.

To learn more about github-script, please visit https://github.com/actions/github-script.

### There’s more...

The editing and debugging experience in the YAML file are not great. However, you can use the script file in the action like this:

```yml
with:
  script: |
    const script = require('./path/to/script.js')
    await script({github, context, core})
```

This way, you can combine the simplicity of the github-script action with a better authoring experience for JavaScript.

The github-script action is a great way to quickly try something out and create a proof of concept for some integrations. With composite actions, you can gradually put it into building blocks that are easy to share. Composite actions are also an easy way to package reusable functionality. As your solution evolves, you probably want to think about moving it to a TypeScript or Docker container action for better maintainability.

Sharing actions to the marketplace
The power of GitHub actions is the community – and sharing is caring. That’s why the GitHub marketplace plays an essential role in empowering community-based workflows. In this recipe, you will add branding and other metadata to one of the actions and share it in the marketplace.

### Getting ready...

I will use the Docker container action we created earlier for this recipe – but you can also use the TypeScript action or composite action. It doesn’t matter. So long as the action resides in its own public repository, it’ll work.

### How to do it...

Navigate to the root of your repository in your browser. GitHub will detect that your repository contains an action.yml file and will propose that you publish a release in a blue banner (see Figure 3.12):

Figure 3.12 – Drafting a release to publish an action to the marketplace

This is the same as going to Releases and clicking Draft a new release (/releases/new).

In the dialogue, GitHub will show some warnings to help you improve your marketplace listing (see Figure 3.13):

Figure 3.13 – Guidance for publishing actions to the marketplace

Click on the link for available icons and colors and pick one of each. I’ll go with bell and purple.

Open your action.yml file in VS Code and add branding and author information:

```yml
name: 'Docker Action Recipe'
description: 'Greet someone'
branding:
  icon: bell
  color: purple
author: 'Michael Kaufmann'
```

A good README.md file is important for the marketplace listing. Add a section for inputs, outputs, and a usage example. Check out https://github.com/wulfland/DockerActionRecipe for a suggestion.
Commit and push your changes.
Go back to your browser and refresh the new release window. The check should now show no warnings and look like what’s shown in Figure 3.14):

Figure 3.14 – The check is successful as has a unique name, branding, description, and a README file

Click Choose a tag, enter v1.0, and click Create new tag (see Figure 3.15):

Figure 3.15 – Creating or choosing a tag to create a release

Add v1.0 as the title of the release. Note that you can automatically generate release notes for your release. However, the results will only be very good if you work with pull requests. You can also add a description manually.
Click Publish release. In the release, you will see the Marketplace and Latest labels (see Figure 3.16):

Figure 3.16 – Content of a release in your repository

Click the Marketplace label. This will bring you to your marketplace listing.
Note the icon with the color you specified under branding in your action.yml, next to the name of the action. The README.md file of your repository will cover the biggest part of the listing. On the right, you have a button to Delist the action (remove it from the marketplace), a version picker, and important links. The first one will bring you back to your repository (see Figure 3.17 for the regions of the listing):

Figure 3.17 – A marketplace listing

Go back to your repository and create a new release called v1.1 by repeating the same steps. Note that this time, the dialogue has a flag set as the latest release (see Figure 3.18). If you forget this, GitHub will not label the release as the latest – independent of the version number you pick as a label:

Figure 3.18 – You have to manually set a release as the latest when creating or editing it

Finally, create a new workflow file or edit an existing workflow in your browser. On the right-hand side, enter the name of your action in the marketplace window. Your action should be found instantly. Note the installation instructions that GitHub automatically creates from your release (see Figure 3.19):

Figure 3.19 – The listing in the workflow editor

Delist your action if you don’t want to keep it in the marketplace, as shown in Figure 3.17.
### How it works...

The GitHub marketplace is built on top of GitHub releases (see (https://docs.github.com/en/repositories/releasing-projects-on-github), which are built on top of git tags.

A tag can be any text – but you are encouraged to use semantic versioning to give the versions a meaning.

Semantic versioning is a formal convention for specifying version numbers for software. It consists of different parts with different meanings. Examples of semantic version numbers are 1.0.0 or 1.5.99-beta. The format is as follows:

```sh
<major>.<minor>.<patch>-<pre>
```

Let’s take a closer look:

Major version: A numeric identifier that gets increased if the version is not backward-compatible and has breaking changes. An update to a new major version must be handled with caution! A major version of zero is for the initial development.
Minor version: A numeric identifier that gets increased if new features are added but the version is backward-compatible with the previous version and can be updated without breaking anything if you need the new functionality.
Patch: A numeric identifier that gets increased if you release backward-compatible bug fixes. New patches should always be installed.
Pre-version: A text identifier that is appended using a hyphen. The identifier must only use ASCII alphanumeric characters and hyphens ([0-9A-Za-z-]). The longer the text, the smaller the pre-version (meaning -alpha < -beta < -rc). A prerelease version is always smaller than a normal version (1.0.0-alpha < 1.0.0).
It is considered best practice to prefix semantic versions in GitHub releases with v (for example, v1.0, v1.0.1, and so on).

See https://semver.org/ for the complete specification regarding semantic versions.

### There’s more...

Versioning with tags opposes some kind of risk as everybody with write permissions to a repository can modify a tag. That’s why, as the maintainer of a GitHub action, you are encouraged to use tag protection rules in addition to your branch protection rules (see https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules). A tag protection rule for v* will prevent everybody without admin permissions to your repository to modify tags starting with a v.

If you want to automate the process of creating semantic versions for your releases and the automatic creation of good release notes, then you can use conventional commits (see https://www.conventionalcommits.org). Conventional commits add a prefix to every commit, indicating if it is a feature or a fix and if it is breaking or not. You can combine this with GitVersion (see https://gitversion.net/docs/) to automatically create semantic versions for your release. You will learn more about this in Chapter 7, Release Your Software with GitHub Actions.
